<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Peachful Space - foldl, foldr, and Infinite Lists</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Peachful Space</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>foldl, foldr, and Infinite Lists</h1>
            <article>
    <section class="header">
        Posted on March 15, 2018
        
    </section>
    <section>
        <p>In Haskell, <code>foldl</code> hangs upon an infinite list, whereas <code>foldr</code> <em>may</em> be able to handle it. To demonstrate this, consider the following functions.</p>
<pre><code>anyL :: [a] -&gt; Bool
anyL list = foldl (\acc item -&gt; acc || item) False list

anyR :: [a] -&gt; Bool
anyR list = foldr (\item acc -&gt; item || acc) False list</code></pre>
<p>(The first argument to <code>foldl</code> or <code>foldr</code> could be simply <code>(||)</code> but we’d like to show the different argument arrangements of it.)</p>
<p><code>anyL (repeat False)</code>, <code>anyL (repeat True)</code> and <code>anyR (repeat False)</code> won’t return. Only <code>anyR (repeat True)</code> returns <code>True</code>.</p>
<p>This is a bit counterintuitive. You’d think <code>foldl</code> works from the left end of an infinite list so it should get some results and once the need is met, stop before getting lost in the infinity.</p>
<p>To clear up this confusion we need to look at <em>data dependency</em>. <code>foldl op seed [x1 .. xn]</code> expands to <code>op ( .. (op (op seed x1) x2) .. ) xn</code>.</p>
<pre><code>       op
      /  \
     .   xn
     .
     op
    /  \
   op  x2
  /  \
seed x1</code></pre>
<p>Note that for <code>foldl</code> to return any result, it needs to evaluate <code>( .. (op (op seed x1) x2) .. )</code>, and <code>xn</code>. It’ll never get <code>xn</code> when dealing with an infinite list, and it’ll need to lazily build <code>( .. (op (op seed x1) x2) .. )</code> which takes up a lot of memory space.</p>
<p>Compare this to <code>foldr op seed [x1 .. xn]</code>, which expands to <code>op x1 (op x2 .. (op xn seed))</code>.</p>
<pre><code>   op
  /  \
 x1  op
    /  \
   .   x2
   .
   op
  /  \
seed xn</code></pre>
<p>For <code>foldr</code> to produce some result, it needs to evaluate <code>x1</code> and <code>(op x2 .. (op xn seed))</code>. Hence with a short-circuit boolean operator like <code>||</code>, <code>foldr</code> can stop at the first <code>True</code> value in the list. Of course if there’s no <code>True</code> it will loop forever.</p>
<p>Last insight - the <code>l</code> and <code>r</code> in the function names mean <em>left-associative</em> and <em>right-associative</em>. What does that mean? Say you have a list <code>[x1, x2, x3]</code>, an initial value <code>seed</code>, and an operator <code>⊕</code>. <code>foldl</code> essentually computes</p>
<pre><code>((seed ⊕ x1) ⊕ x2) ⊕ x3</code></pre>
<p>while <code>foldr</code> does</p>
<pre><code>x1 ⊕ (x2 ⊕ (x3 ⊕ seed))</code></pre>
<p>.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
