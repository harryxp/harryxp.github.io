<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Peachful Space - The Y Combinator, Revisited</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Peachful Space</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>The Y Combinator, Revisited</h1>
            <article>
    <section class="header">
        Posted on July 11, 2017
        
    </section>
    <section>
        <p>In a <a href="y-comb.html">previous post</a> we talked about the Y combinator. We demonstrated Y and then its use. In this short post I’d like to take a stab from the other direction.</p>
<p>Still take factorial for example:</p>
<pre><code>fact = \n -&gt; ... fact ...</code></pre>
<p>How do we do this without recursion? The trick is to abstract over <code>fact</code> itself…</p>
<pre><code>fact = (\f -&gt; \n -&gt; ... f ...) fact</code></pre>
<p>Or</p>
<pre><code>fact = c fact   where c = \f -&gt; \n -&gt; ... f ...</code></pre>
<p><code>c</code> is <em>almost the same</em> as <code>fact</code> except that instead of relying on recursion, it takes an argument <code>f</code> as the next step.</p>
<p>Now, what we want - <code>fact</code> - is the solution to the equation <code>fact = c fact</code>, and also a fixed point of <code>c</code>. Let’s try to apply <code>fix</code> to <code>c</code>.</p>
<pre><code>fix f = f (fix f)

fact
= fix c
= c (fix c)
= c (c (fix c))
= ...</code></pre>
<p>Our intuition from the previous post still applies - the fixed-point combinator captures the repeating nature of the computation, whereas <code>c</code> is the user-provided computation. It would seem that the above expansion continues forever but in a call-by-need language like Haskell this</p>
<pre><code>c = \f -&gt; \n -&gt; if n == 0 then 1 else n * f (n-1)</code></pre>
<p>would hit <code>n == 0</code> first.</p>
<p>So to turn a recursive function <code>f</code> into a non-recursive one, we could</p>
<ol style="list-style-type: decimal">
<li>Devise a function <code>c</code> that’s almost the same as <code>f</code> but replace every call to itself with a call to an argument.</li>
<li>Then <code>fix c</code> is what you want.</li>
</ol>
<p>Let’s try this on another equally famous example in ghci - the Fibonacci :</p>
<pre><code>&gt; let fib = \n -&gt; if n == 1 || n == 2 then 1 else fib (n-1) + fib (n-2)
&gt; fib 6
8

&gt; let c f = \n -&gt; if n == 1 || n == 2 then 1 else f (n-1) + f (n-2)
&gt; fix c 6
8</code></pre>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
