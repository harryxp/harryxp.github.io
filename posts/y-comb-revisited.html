<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Peachful Space - The Y Combinator, Revisited</title>
        <link href="https://fonts.googleapis.com/css?family=Work+Sans" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Peachful Space</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>The Y Combinator, Revisited</h1>

            <div class="info">
    Posted on July 11, 2017
    
</div>

<p>In a <a href="y-comb.html">previous post</a> we talked about the Y combinator. We demonstrated Y and then its use. In this short post I’d like to take a stab from the other direction.</p>
<p>Still take factorial for example:</p>
<pre><code>fact = \n -&gt; ... fact ...</code></pre>
<p>How do we do this without recursion? The trick is to abstract over <code>fact</code> itself…</p>
<pre><code>fact = (\f -&gt; \n -&gt; ... f ...) fact</code></pre>
<p>Or</p>
<pre><code>fact = c fact   where c = \f -&gt; \n -&gt; ... f ...</code></pre>
<p><code>c</code> is <em>almost the same</em> as <code>fact</code> except that instead of relying on recursion, it takes an argument <code>f</code> as the next step.</p>
<p>Now, what we want - <code>fact</code> - is the solution to the equation <code>fact = c fact</code>, and also a fixed point of <code>c</code>. Let’s try to apply <code>fix</code> to <code>c</code>.</p>
<pre><code>fix f = f (fix f)

fact
= fix c
= c (fix c)
= c (c (fix c))
= ...</code></pre>
<p>Our intuition from the previous post still applies - the fixed-point combinator captures the repeating nature of the computation, whereas <code>c</code> is the user-provided computation. It would seem that the above expansion continues forever but in a call-by-need language like Haskell this</p>
<pre><code>c = \f -&gt; \n -&gt; if n == 0 then 1 else n * f (n-1)</code></pre>
<p>would hit <code>n == 0</code> first.</p>
<p>So to turn a recursive function <code>f</code> into a non-recursive one, we could</p>
<ol style="list-style-type: decimal">
<li>Devise a function <code>c</code> that’s almost the same as <code>f</code> but replace every call to itself with a call to an argument.</li>
<li>Then <code>fix c</code> is what you want.</li>
</ol>
<p>Let’s try this on another equally famous example in ghci - the Fibonacci :</p>
<pre><code>&gt; let fib = \n -&gt; if n == 1 || n == 2 then 1 else fib (n-1) + fib (n-2)
&gt; fib 6
8

&gt; let c f = \n -&gt; if n == 1 || n == 2 then 1 else f (n-1) + f (n-2)
&gt; fix c 6
8</code></pre>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
